1
导言
    首先，我们要知道面向对象编程和面向过程编程这两者之间的区别。
0
    面向对象编程：在现实问题中抽象出一个或者多个对象.如在2048中，我抽象出了一个对象“棋盘”，然后对于这个棋盘的操作都基于class qipan中的函数和变量来执行。

    面向过程编程：按照正常过程直接编程。比如在2048的编程中，创建棋盘、随机生成两个数、反复读取键盘输入并处理、判断游戏是否结束，面向这么一整个过程一条线编程下来，这就是面向过程编程。
0
    两者中的联系与区别：在面向过程编程中，我们可以看到，整个编程过程其实已经被划分成了好几块，通过模块化思想，可以把这些过程拆解成一个个的函数；然后更进一步地，如果我们发现这些函数的内在联系――即每个操作都是基于棋盘做出的动作――那么我们就可以将这些操作归到一起，整合到一个对象的名下，即：我们从面向过程编程跨越到了面向对象编程。
0
    Ok，虽然但是代码十分简单，我们接下来就在简短的代码分析中进一步领略这两者之间的联系与区别、以及加强对于面向对象编程的印象（ta其实并不难
1
第一步，需求分析
    我们首先认识一下我们要制作的小游戏――2048。它的基本游戏规则是通过上下左右的移动使相同的数字相加以达到在一定的棋盘空间中容纳更大数字

0

    所以我们要实现的关键的点其实只有四条：在棋盘上随机生成2或者4，监控键盘输入的方向键，基于输入的方向处理棋盘上的数字，检测游戏何时停止。

1
第二步，架构结构
    因为对于数据的所有处理都可以视作棋盘的动作，而数据都可以视为棋盘的属性，那么这个时候就特别适合将 棋盘 定义为一个类，然后与其相关的数据和函数（即动作）归档到一起。
0
'                                                                    //qipan.h
'                                                                   #pragma once
'    所以我们先定义了一个名字为 qipan 的类，这个过程会生             class qipan {
'成两个文件:qipan.h和qipan.cpp，上课有认真听讲的同学应该                public:
'立刻就能反应过来，这是多文件结构。                                     qipan();
'
'    其中public关键字意思是说下属的函数和变量是整个项目都               void rand();
'可以引用的                                                             void move(int);
'    其中qipan()是初始化函数，当这个对象被建立的时候可以                void up();
'通过这个函数执行一些初始化选项，比如在棋盘上生成两个随机               void down();
'的2                                                                    void left();
'    void move(int)是整合不同方向的移动的函数，负责处理键               void right();
'盘的输入值并将其分配任务给具体的不同方向处理函数即up()、               int color(int);
'down()、left()、right()这四个具体函数                                  void Print();
'    int color(int)是根据数字返回颜色的函数，但是因为控制               bool isOver();
'台能用的颜色只有红、蓝、绿、白、黑，所以这个功能就搁浅了
'    void Print()函数功能如其名，负责打印棋盘，让它显示在               int qp[4][4];
'控制台上                                                               bool canMoveUp;
'    bool isOver()是一个布尔值的函数，基于canMoveUp等四个               bool canMoveDown;
'布尔变量判断游戏是否结束，判断游戏结束时返回true                       bool canMoveLeft;
'                                                                       bool canMoveRight;
'                                                                   };

1
    那么我们为什么会用到多文件结构呢？就像我们引入类这个概念是一样的，这使整个代码中模块的区分度更大，使得代码显得更有层次性也更易读，一方面方便前期的筹划分工和代码编写，另一方面也使得后期的代码维护和检修更简单
0
    另外可以看到在这个头文件里，整个过程被拆解成了几个非常清晰的小步骤，这是结构化编程思想的应用，而进一步地我们也可以联想到，类、多文件这样的概念也是结构化编程的一种推广

1
第三步，函数详解
    那么我们接下来简单地讲解每一个函数所承载的功能及其实现方式（虽然标题是详解
0
'                       //qipan.cpp                              //2048.cpp
'    这条就是类的初     qipan::qipan()
'始化的函数，在主代     {                                        qipan a;
'码中就以qipan a;来     for (int i = 0; i < 4; i++)
'创建一个名字为a的              for (int j = 0; j < 4; j++)
'棋盘（即我们所讲的                 qp[i][j] = 0;
'对象）                     rand();
'    前面的循环、           rand();
'rand()和后边的四个         canMoveUp=1;
'赋值都是一些初始化         canMoveDown=1;
'准备，防止随机初值         canMoveLeft=1;
'影响代码正常运行           canMoveRight=1;
'                       }

1

’                           //qipan.cpp
'                            void qipan::rand()
'                            {
'    这就是我们的随机            default_random_engine e;
'数生成函数，为了科学            uniform_real_distribution<double> u(0, 4);
'随机出这个位置我用了            int a1 =u(e),a2 =u(e),i=0;
'C++11引入的random库，           while (qp[a1][a2] != 0 && i < 100)
'第一句就是建立了一个                a1 = u(e), a2 = u(e), i++;
'名称为e的对象，通过             qp[a1][a2] = 2;
'随机数的生成引擎完成        }
'随机数的生成

1

'                           //qipan.cpp                      //qipan.cpp
'                           void qipan::move(int key)        void qipan::left() {
'                           {                                    canMoveLeft = 0;
'    这是我们的移动处           switch (key) {                   for (int i = 0; i < 4; i++) {
'理函数，先从主代码中           case 72:                             for (int j = 1, a = 0; j < 4; j++) {
'获取键盘输入的值，再               up();                                if (qp[i][j] != 0) {
'根据这个值分析应该做               rand();                                  if (qp[i][j] == qp[i][a] && a != j) {
'出的动作，再交给具体               break;                                       qp[i][j] += qp[i][a];
'动作执行函数去执行             case 75:                                         qp[i][a] = 0;
'    然后对于具体的动               left();                                  }
'作执行函数……在这里               rand();                              else
'就不再详讲，大家会在               break;                                   a = j;
'大计基后面关于算法学           case 77:                             }
'习的课上了解的，这里               right();                     }
'也给出其中一段代码给               rand();                      for (int j = 0; j < 4; j++) 
'大家粗略看下                       break;                           for (int k = 3; k > 0; k--) 
'                               case 80:                                 if (qp[i][k - 1] == 0)
'                                   down();                                  swap(qp[i][k - 1], qp[i][k]), canMoveLeft++;
'                                   rand();                  }
'                                   break;
'                               }
'                           }

1

’                          //qipan.cpp
'    然后就是棋盘打印       void qipan::Print()
'的函数，主要的操作是       {
'清除前面打印的内容并           system("cls");
'打印新的内容                   for (int i = 0; i < 4; i++) {
'    然后Sleep(150)可               for (int j = 0; j < 4; j++)
'能会让大家有点看不懂，                 printf("%4d|", qp[i][j]);
'就是程序会在这里停顿               cout << '\n';
'0.15s防止出现闪屏（大          }
'概可以，hhh                    Sleep(150);
'                            }

1


'                            HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);//全局句柄
'    最后我们再来看看        int main()
'主代码。第一句是获取        {
'全局句柄，为后面获取            SetConsoleTitle(L"2048体验");
'键盘输入作铺垫                  qipan a;
'    当对象a被创建了之           int kb=72;
'后，我们可以看见对于            a.Print();
'函数和变量的引用变得            while (((kb == 72 || kb == 75 || kb == 77 || kb == 80|| kb > 150) && !a.isOver())) {
'十分方便：a.Print()                 if (_kbhit()) {
'和a.isOver()就相当于                    kb = _getch();
'分别引用了一长串代码，                  a.move(kb);
'极大简化了代码，也提                    a.Print();
'高了代码的易读性、易                }
'维护性                          }
'                                cout << "Game Over\n";
'                            }

1
第四步，尾声总结
    希望借这个实例给大家多一个基于面向对象编程思想的代码案例的参考吧。相信大家通过对这段并不像教程的教程小程序中的对代码的相关描述介绍能够对面向对象编程思想有进一步的了解，也希望大家在日后的比较大的程序创作的过程中能够实际运用并且能够更直接感受到这种编程思维所架构的程序的简洁清晰。
0
    那么本教程就即将结束啦----撒花-----愿我们帮助到每一名打开这份教程的人！
2








